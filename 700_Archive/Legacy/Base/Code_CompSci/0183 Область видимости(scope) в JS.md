# Понятие
Область видимости - это часть программы,где мы можем обратиться к переменной,функции или объекту. Это часть можем быть функция,блок иои вся программа - то есть мы всегда находимся минимум в одной области видимости.
Можно провести аналогию с коробкой,в которую мы кладем переменные. Переменные в одной коробке,могут общаться друг с другом. 
## Детали
Переменные также могут получить доступ к переменным из коробки,в которые они находятся. Коробка в коробке.
![[Pasted image 20230321113308.png]]
*Области видимости помогают скрыть переменные от нежелательного доступа, управлять побочными эффектами и разбивать код на смысловые блоки*
### Виды scope
1. *Глобальная область видимости*
Глобальная область видимости - самая внешняя коробка из всех. Когда мы просто создаем переменную,вне функций,вне модулей, то эта переменная попадает в глобальную область видимости.
![[Pasted image 20230321113906.png]]
Переменные в глобальной области видимости называются *глобальные переменными* и доступны всем.
Самая известная - это **console**.
![[Pasted image 20230321114131.png]]
JS в браузерах так устроен, что глобальные переменные попадают в объект **window**. Очень грубо говоря,то можно сказать,что **window** в случае браузера - это и есть глобальная область видимости.
![[Pasted image 20230321114915.png]]
Глобальный объект **window** - это объект ,который дает доступ к Web API браузера. **window** рекурсивно содержит сам себя, потому что все глоюальные объекты находятся в **window**. 
2. *Блочная область видимости*
Блочная область видимости ограничена программным блоком , обозначенным { и }. Постейший пример такой области это выражение внутри скобок:
![[Pasted image 20230321115525.png]]
Переменная b скрыта внутри блока,поэтому обработчик не может найти его. Она доступна лишь внутри скобок,никак не снаружи. 
Скобки могут не только отделять тело, но и обхватывать в себя. Это полезно в конструкциях с **switch**. Например:
![[Pasted image 20230321120018.png]]
3. *Функциональная область видимости*
Функциональная область видимости - это область видимости в пределах тела функции. То есть, ограничена { и } функции.
![[Pasted image 20230321120313.png]]
Функциональная область видимости - очень мощный инструмент для разделения кода. Во первых, мы можем не боятся за "пересечени имен", то есть, мы можем использовать одно и тоже имя для разных **let,const** 
![[Pasted image 20230321120631.png]]
Функциям доступны лишь те переменные,которые находятся в ее коробке и в родительских коробках.
![[Pasted image 20230321120845.png]]
Здесь нет ошибки,потому что функция доступна своя область видимости, а также область видимости функции **outer**(родителя). 
Такое поведение, когда переменные родительских коробок становятся доступны в дочерних, называется *наследованием областей видимости*. 
Заметим, что у функции **inner** нет никаких локальных переменных - она работает только с локальной переменной функции **outer**. 
Это называют *лексической областью видимости*. 
Сокрытие "внутренностей" позволяет создавать независимые блоки кода. Это полезно,когда мы хотим запустить какой то модуль в браузере с уверенностью, что он не крашнет другие блоки кода.
#### Изоляция модулей с помощью IIFE
Immediately Invoked Function Expression, IIFE — это функция, которая выполняется сразу же после того, как была определена.
Записывается IIFE так:
![[Pasted image 20230321121745.png]]
Разберем по частям(не понял)
![[Pasted image 20230321122145.png]]
##### Функции внутри функций и замыкания
![[Pasted image 20230321122542.png]]
По дефолту, родитель делится с функциями со своей дочкой.
Но что если мы вернем из функции **outer** функцию **inner**?
![[Pasted image 20230321122718.png]]
Теперь мы не можем просто вызывать функцию **outer**, но и присвоить результат вызова какой то переменной:
![[Pasted image 20230321122821.png]]
Теперь в переменной **accessToInner**  находится функция **inner**, у которой всё ещё есть доступ к локальной переменной a функции **outer!**
То есть мы смогли «обойти» область видимости? Не совсем.
Мы получили доступ к переменной **а** через функцию **inner**, но только в том ввиде и стакими ограничениями, которые описаны при создании функции **inner**. 
То есть,мы можем читать, но не менять. Онли законсолить.
Это полезно,если мы хотим дать ограниченный доступ к внутренностям модуля.
Такое контролируемрое сокрытие лоступа с помощью области видимости называется *замыканием*. 
Замыкания удобны тем, что каждый новый вызов создает отдельный scope , в котрой значения абсолютно независимы друг от друга.


tag: #dev 
links: [[180 Hoisting in JS]],[[0181 Event bubbling and Capturing in JS]]
src: [Области видимости — JavaScript — Дока (doka.guide)](https://doka.guide/js/closures/)