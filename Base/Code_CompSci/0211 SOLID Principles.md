# Принципы SOLID

## Краткий обзор (Executive Summary)

Данный документ представляет собой синтез ключевых идей, изложенных в видеоматериале "SOLID ПРИНЦИПЫ простым языком". В нем раскрывается суть пяти фундаментальных принципов объектно-ориентированного программирования и проектирования, известных под акронимом SOLID. Основная цель этих принципов — создание масштабируемых, поддерживаемых и понятных программных систем. Они служат общим языком для разработчиков, снижая порог вхождения в новые проекты и минимизируя количество ошибок, возникающих при внесении изменений. Каждый принцип решает специфический класс проблем, связанных с сильной связанностью кода, сложностью его модификации и низкой читабельностью.

**Ключевые выводы:**

- **Назначение принципов:** SOLID, наряду с другими парадигмами (GRASP, паттерны GoF), формирует стандартизированный подход к разработке, который позволяет создавать предсказуемые и легко расширяемые приложения, сводя к минимуму объем уникальных "проектных знаний".
- **S - Принцип единственной ответственности:** Каждая программная сущность (класс, функция, компонент) должна иметь только одну зону ответственности и решать одну-единственную задачу.
- **O - Принцип открытости/закрытости:** Программные сущности должны быть открыты для расширения, но закрыты для изменения. Новый функционал следует добавлять путем создания нового кода, а не модификации существующего.
- **L - Принцип подстановки Барбары Лисков:** Объекты дочерних классов должны быть полностью взаимозаменяемы с объектами родительского класса, не нарушая логику работы программы.
- **I - Принцип разделения интерфейса:** Лучше иметь множество узкоспециализированных интерфейсов, предназначенных для конкретных клиентов, чем один общий интерфейс широкого назначения.
- **D - Принцип инверсии зависимостей:** Модули высокого уровня не должны зависеть от модулей низкого уровня. И те, и другие должны зависеть от абстракций.

--------------------------------------------------------------------------------

## Ключевые концепции и цели принципов разработки

Перед детальным рассмотрением каждого принципа важно понять их общую цель и ценность в процессе разработки программного обеспечения.

### 1. Единый язык и снижение порога вхождения

Принципы и паттерны проектирования позволяют разработчикам "разговаривать на одном языке". Когда команда следует общепринятым подходам, таким как SOLID, новым участникам гораздо проще вникнуть в проект. Это сводит к минимуму объем уникальных "проектных знаний", которые требуются для понимания архитектуры, что экономит время и ресурсы. В идеальном мире, к которому стремятся разработчики, проектные знания сведены к минимуму за счет использования фреймворков и стандартизированных подходов.

### 2. Создание "хорошего" кода

Принципы SOLID помогают писать "хороший" код, который обладает следующими характеристиками:

- **Масштабируемость:** Внесение изменений в проект должно быть легким и не должно приводить к каскадным сбоям. Проект, написанный с учетом этих принципов, легко поддерживать и изменять даже спустя годы.
- **Низкий порог вхождения:** Как уже упоминалось, использование базовых принципов и паттернов делает код более предсказуемым для новых разработчиков.
- **Простота:** Принципы не должны приводить к излишнему усложнению. Код должен оставаться простым и понятным.

### 3. "Формулы" в мире программирования

Паттерны и принципы можно сравнить с математическими формулами. Подобно тому, как математики не выводят формулу интеграла каждый раз заново, а используют готовую из таблицы, программисты используют принципы для решения типовых проблем, выявленных за годы существования индустрии. Это готовые решения для классических ошибок и нюансов разработки.

## S: Принцип единственной ответственности (Single Responsibility Principle, SRP)

**Определение:** Один класс (или любая другая программная сущность, например, функция или компонент) должен решать только одну задачу и иметь одну зону ответственности.

Этот принцип направлен на декомпозицию. Сущности не должны быть "объектами-богами" (God Object), выполняющими множество несвязанных функций, таких как логирование, сохранение в базу данных, отправка по сети и отображение.

**Решаемые проблемы и преимущества:**

- **Снижение связанности:** Когда сущность решает много задач, код становится сильно связанным. Изменение в одной части функционала может сломать другую.
- **Повышение читабельности:** Класс на несколько тысяч строк кода крайне сложен для понимания и поддержки.
- **Упрощение внесения изменений:** Изменять небольшой, сфокусированный модуль гораздо проще, быстрее и дешевле, чем копаться в огромном монолитном классе.
- **Упрощение контроля версий (Git):** Когда несколько разработчиков правят один большой файл, это неизбежно приводит к конфликтам слияния и ошибкам. Декомпозиция позволяет вести параллельную разработку.
- **Упрощение тестирования:** Тестировать небольшие, изолированные модули значительно проще.

**Практические примеры:**

1. **Класс-сущность:**
    - **Нарушение:** Класс, описывающий некую сущность (например, `Post`), содержит методы для собственного сохранения в базу данных (`save()`), отправки по HTTP (`send()`), печати (`print()`) и логирования (`log()`).
    - **Соблюдение:** Логика разделяется на несколько классов. Исходный класс остается моделью данных. Появляются отдельные классы: `Repository` (для работы с БД), `HttpSender` (для отправки по сети), `Logger` (для логирования) и `Printer` (для печати). Каждый класс решает свою локальную задачу.
2. **Сервис для получения данных:**
    - **Нарушение:** Класс `DataFetcher` содержит как низкоуровневые методы для HTTP-запросов (`get`, `post`), так и высокоуровневую бизнес-логику (`getUser`, `getRequisites`). По мере добавления новых методов класс разрастается и смешивает разные уровни абстракции.
    - **Соблюдение:** Создается базовый `HttpClient`, отвечающий только за выполнение HTTP-запросов. Бизнес-логика выносится в специализированные сервисы, такие как `UserService` и `RequisiteService`, которые внутри себя используют `HttpClient`.
3. **Frontend-компонент:**
    - **Нарушение:** Один компонент-форма (`RequisitesForm`) отвечает за отрисовку полей, валидацию (с разными правилами для российских и иностранных реквизитов), а также за бизнес-логику создания и обновления этих реквизитов. Компонент становится перегруженным условной логикой.
    - **Соблюдение:** Компонент разделяется на несколько "кирпичиков". Создается "глупый" компонент-форма, единственная задача которого — отрисовка UI. Логика валидации и сохранения выносится во внешние компоненты-обертки (`CreateRequisites`, `UpdateRequisites`), которые используют этот "глупый" компонент и передают в него нужную логику через props.

## O: Принцип открытости/закрытости (Open/Closed Principle, OCP)

**Определение:** Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для изменения.

Это означает, что добавление нового функционала должно происходить путем написания нового кода (например, создания нового класса), а не путем модификации существующего, уже работающего и протестированного кода. Изменение старого кода нежелательно, так как требует проведения полного регрессионного тестирования, чтобы убедиться, что ничего не сломалось.

**Решаемые проблемы и преимущества:**

- **Минимизация регрессионного тестирования:** Не изменяя старый код, мы снижаем вероятность появления ошибок в уже работающем функционале.
- **Стабильность системы:** Существующая кодовая база остается нетронутой и стабильной.
- **Требует продуманной архитектуры:** Для эффективного применения принципа необходимо на раннем этапе выявлять части системы, которые могут изменяться, и создавать для них правильные абстракции.

**Практические примеры:**

1. **Класс оружия в игре:**
    - **Нарушение:** В классе `Weapon` есть поле `type` (меч, арбалет). Метод `attack` содержит большую конструкцию `if-else` или `switch`, которая определяет логику атаки в зависимости от типа. Чтобы добавить новый вид оружия (нож), необходимо изменять этот метод.
    - **Соблюдение:** Используется наследование и полиморфизм. Создается базовый класс `Weapon` и/или интерфейс `Attacker`. Конкретные виды оружия (`Sword`, `Crossbow`, `Knife`) наследуются от базового класса и реализуют метод `attack` со своей уникальной логикой. Добавление нового оружия сводится к созданию нового класса, не затрагивая существующие.
2. **Сортировка списка:**
    - **Нарушение:** В классах `PersonList` и `MusicList` есть логика, которая выбирает алгоритм сортировки (например, пузырьковую для малых списков и быструю для больших). Эта условная логика дублируется и требует изменения в нескольких местах, если правила изменятся.
    - **Соблюдение:** Создается абстракция `SortClient`, которая инкапсулирует в себе логику выбора алгоритма сортировки. Классы `PersonList` и `MusicList` теперь зависят от этого клиента, а не от конкретных алгоритмов. Изменить логику выбора сортировки теперь можно в одном месте — внутри `SortClient`.

## L: Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)

**Определение:** Функции, которые используют базовый (родительский) тип, должны иметь возможность использовать объекты производных (дочерних) типов, не зная об этом, при этом логика работы программы не должна нарушаться. Проще говоря, наследуемый класс должен **дополнять**, а не **замещать** поведение базового класса.

**Решаемые проблемы и преимущества:**

- **Предсказуемость поведения:** Гарантирует, что подтипы ведут себя так же, как их базовые типы, что предотвращает неожиданные ошибки при замене объектов.
- **Корректность иерархии наследования:** Помогает строить логически верные иерархии классов.

**Практические примеры:**

1. **Иерархия разработчиков:**
    - **Нарушение:** Есть базовый класс `Developer` с методом `writeCode()`. От него наследуется `MobileDeveloper`, который по какой-то причине переопределяет метод `writeCode()` так, что он ничего не делает или выбрасывает исключение. Если система ожидает, что любой `Developer` может писать код, то при передаче объекта `MobileDeveloper` логика нарушится.
2. **Работа с базами данных:**
    - **Нарушение:** Есть базовый класс `Database` с методами `connect`, `read`, `write` и `joinTables`. От него наследуются `MySQLDatabase` (реляционная БД, `joinTables` уместен) и `MongoDatabase` (нереляционная, где нет таблиц). Класс `MongoDatabase` вынужден реализовывать `joinTables`, выбрасывая ошибку. Если в коде, работающем с `Database`, вызывается `joinTables`, замена MySQL на Mongo приведет к падению приложения.
    - **Соблюдение:** Иерархия перестраивается. Создается базовый `Database` только с общими методами (`connect`, `read`, `write`). От него наследуются `SQLDatabase` (добавляет `joinTables`) и `NoSQLDatabase` (добавляет свои специфичные методы, например `createIndex`). Конкретные классы `MySQLDatabase` и `MongoDatabase` наследуются уже от `SQLDatabase` и `NoSQLDatabase` соответственно. Таким образом, любой объект типа `Database` гарантированно будет иметь только предсказуемый набор общих методов.

## I: Принцип разделения интерфейса (Interface Segregation Principle, ISP)

**Определение:** Программные сущности не должны зависеть от методов, которые они не используют. Другими словами, нельзя заставлять клиента реализовывать интерфейс, которым он не пользуется.

Этот принцип тесно связан с SRP и призывает создавать маленькие, узкоспециализированные интерфейсы вместо больших и "толстых".

**Решаемые проблемы и преимущества:**

- **Уменьшение связанности:** Классы зависят только от тех методов, которые им действительно нужны.
- **Более чистый код:** Классам не нужно реализовывать "пустые" методы или выбрасывать из них исключения.
- **Повышение гибкости:** Маленькие интерфейсы легче комбинировать и переиспользовать.

**Практические примеры:**

1. **Интерфейс оружия:**
    - **Нарушение:** Создан один интерфейс `IWeapon` с методами `attack()` и `reload()`. Класс `Pistol` реализует оба. Класс `Knife` может только атаковать, но вынужден реализовывать метод `reload()`, который для него бессмысленен.
    - **Соблюдение:** Интерфейс разделяется на два: `IAttackingWeapon` (с методом `attack`) и `IReloadableWeapon` (с методом `reload`). `Pistol` реализует оба интерфейса, а `Knife` — только `IAttackingWeapon`.
2. **Роутер для Server-Side Rendering (SSR):**
    - **Нарушение:** Создан единый интерфейс `IRouter` для клиентского и серверного роутера. Он содержит методы, нужные только на клиенте (`navigate`, `addEventListener`), и методы, общие или нужные только на сервере (`parseUrl`). В итоге серверная реализация вынуждена содержать ненужные клиентские методы, и наоборот.
    - **Соблюдение:** Создается базовый интерфейс с общей функциональностью (`IUrlParser`). Затем для клиента и сервера создаются свои интерфейсы (`IClientRouter`, `IServerRouter`), которые либо расширяют базовый, либо просто используются в нужных классах. Таким образом, каждый класс реализует только те методы, которые ему необходимы.

## D: Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)

**Определение:**

1. Модули высокого уровня не должны зависеть от модулей более низкого уровня. И те, и другие должны зависеть от абстракций.
2. Абстракции не должны зависеть от деталей. Детали (конкретные реализации) должны зависеть от абстракций.

**Решаемые проблемы и преимущества:**

- **Слабая связанность:** Высокоуровневая бизнес-логика не привязана к конкретным низкоуровневым реализациям (например, к конкретной базе данных или API).
- **Гибкость и заменяемость:** Низкоуровневые модули можно легко заменять, не затрагивая высокоуровневые. Например, можно заменить `LocalStorage` на `PostgreSQL`, просто "подставив" другую реализацию общего интерфейса.
- **Упрощение тестирования:** Зависимости можно легко подменять "моками" (заглушками) в тестах.

**Практические примеры:**

1. **Хранилище данных:**
    - **Нарушение:** Высокоуровневый модуль (например, сервис постов) напрямую создает экземпляр низкоуровневого класса `LocalStorageRepository` и работает с ним. Чтобы перейти на `DatabaseRepository`, придется изменять код этого сервиса.
    - **Соблюдение:** Создается абстракция — интерфейс `IRepository`. Высокоуровневый сервис зависит только от этого интерфейса. Конкретная реализация (`LocalStorageRepository` или `DatabaseRepository`) передается в сервис извне (через конструктор или сеттер). Таким образом, зависимость "инвертируется": не сервис зависит от хранилища, а оба они зависят от общего интерфейса.
2. **Музыкальное приложение:**
    - **Нарушение:** Код приложения в разных местах напрямую использует `YandexMusicApi`. Чтобы добавить поддержку `SpotifyApi`, придется вносить изменения во множество файлов.
    - **Соблюдение:** Создается общий интерфейс `IMusicApi` с методом `getTracks()`. Создается класс-абстракция `MusicClient`, который принимает в конструкторе объект, реализующий `IMusicApi`. Все приложение работает только с `MusicClient`. Чтобы сменить провайдера музыки, достаточно в одном месте при создании `MusicClient` передать ему нужную реализацию (`YandexMusicApi` или `SpotifyApi`).

## Итоговый обзор принципов SOLID

|   |   |
|---|---|
|Принцип|Краткое определение из источника|
|**S: Единственная ответственность**|Для каждого модуля в системе должно быть предопределено одно-единственное назначение, и все ресурсы для решения этой задачи должны быть инкапсулированы в этот модуль.|
|**O: Открытость/закрытость**|Программные модули должны быть открыты для расширения, но закрыты для модификации.|
|**L: Подстановка Барбары Лисков**|Объекты в программе должны быть заменяемыми на экземпляры их дочерних классов без нарушения логики работы программы.|
|**I: Разделение интерфейса**|Множество интерфейсов, предназначенных для конкретного клиента, гораздо лучше, чем один интерфейс общего назначения. Класс не должен содержать методы, которые он не использует.|
|**D: Инверсия зависимостей**|Зависимости должны строиться на абстракциях, а не на чем-то конкретном. Модули высокого уровня не должны зависеть от модулей низкого уровня.|


src: https://www.youtube.com/watch?v=TxZwqVTaCmA
summarized by: notebook llm
links: 